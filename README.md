# Algorithmic Programs

Welcome to the **Algorithmic Programs** repository!
I created this repository to share my implementations of key algorithms and data structures for practical coding and learning.

## ðŸ“š Contents

This repository includes implementations of the following algorithms:

### Sorting Algorithms

- **Bubble Sort**: `bubble_sort.py`  
  **Theory**: Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.  
  **Time Complexity**: O(nÂ²)  
  **Space Complexity**: O(1)  

- **Merge Sort**: `merge_sort.py`  
  **Theory**: Merge Sort divides the unsorted list into two approximately equal halves, recursively sorts each half, and then merges the sorted halves.  
  **Time Complexity**: O(n log n)  
  **Space Complexity**: O(n)  

- **Quick Sort**: `quick_sort.py`  
  **Theory**: Quick Sort selects a 'pivot' element from the array and partitions the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.  
  **Time Complexity**: O(n log n) (average), O(nÂ²) (worst-case)  
  **Space Complexity**: O(log n)  

- **Insertion Sort**: `insertion_sort.py`  
  **Theory**: Insertion Sort builds the final sorted array one item at a time by comparing each element with the already sorted part of the array and inserting it into the correct position.  
  **Time Complexity**: O(nÂ²)  
  **Space Complexity**: O(1)  

- **Selection Sort**: `selection_sort.py`  
  **Theory**: Selection Sort repeatedly selects the smallest (or largest) element from the unsorted portion of the list and moves it to the end of the sorted portion.  
  **Time Complexity**: O(nÂ²)  
  **Space Complexity**: O(1)  

### Searching Algorithms

- **Binary Search**: `binary_search.py`  
  **Theory**: Binary Search works on sorted arrays by repeatedly dividing the search interval in half. If the value is less than the middle element, it searches the left half; otherwise, it searches the right half.  
  **Time Complexity**: O(log n)  
  **Space Complexity**: O(1)  

- **Linear Search**: `linear_search.py`  
  **Theory**: Linear Search sequentially checks each element of the array until the desired element is found or the list is exhausted.  
  **Time Complexity**: O(n)  
  **Space Complexity**: O(1)  
## ðŸš€ Getting Started
